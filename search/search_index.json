{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Redsun project","text":"<p>Redsun - event-driven, unopinionated, Python-native framework for building customly-tailored applications.</p> <p>This project is developed in the context of microscopy and microscopy-related hardware, but aims to be flexible to be used in other scientific domains.</p> <ul> <li>redsun application</li> <li>sunflare, toolkit for Redsun</li> <li>redsun plugin template (docs WiP)</li> </ul> <p>Warning</p> <p>This project is under active development and may (and probably will) see breaking changes. Use at your own risk.</p>"},{"location":"project-list/","title":"Other projects","text":"<p>This document presents a (not-so) curated list of open-source projects related to hardware control via software.</p> <p>Other projects are listed in the Smart Microscopy website.</p> <p>This list should include only projects that have been actively developed in the last 5 years.</p> <p>We'll update this list as we go.</p> <p>Any contribution is welcome.</p> <ul> <li>PyMoDAQ <sup>1</sup>: a modular data acquisition framework.</li> <li>PyMoDAQ leverages a similar approach to Redsun concept of plugins (called \"modules\" in PyMoDAQ), but it is tied to the Qt framework.</li> <li>bluesky <sup>2</sup>: event-driven, unopinionated framework for experiment control in Python.<ul> <li>We use this!</li> </ul> </li> <li>qudi-core <sup>3</sup>: a framework for modular multi-instrument and multi-computer measurement applications.<ul> <li>qudi-core leverages a similar approach to Redsun concept of plugins (called \"addons\" in qudi), but it is tied to the Qt framework.</li> </ul> </li> </ul> <ol> <li> <p>Weber, S\u00e9bastien. (2021). PyMoDAQ: An open-source Python-based software for modular data acquisition. Review of Scientific Instruments. 92. 045104. doi:10.1063/5.0032116 \u21a9</p> </li> <li> <p>Daniel Allan, Thomas Caswell, Stuart Campbell &amp; Maksim Rakitin (2019) Bluesky's Ahead: A Multi-Facility Collaboration for an a la Carte Software Project for Data Acquisition and Management, Synchrotron Radiation News, 32:3, 19-22, DOI: doi:10.1080/08940886.2019.1608121 \u21a9</p> </li> <li> <p>Jan M. Binder, Alexander Stark, Nikolas Tomek, Jochen Scheuer, Florian Frank, Kay D. Jahnke, Christoph M\u00fcller, Simon Schmitt, Mathias H. Metsch, Thomas Unden, Tobias Gehring, Alexander Huck, Ulrik L. Andersen, Lachlan J. Rogers, Fedor Jelezko, Qudi: A modular python suite for experiment control and data processing, SoftwareX, Volume 6, 2017, Pages 85-90, ISSN 2352-7110, doi:10.1016/j.softx.2017.02.001 \u21a9</p> </li> </ol>"},{"location":"governance/","title":"Governance","text":"<p>This section provides information about the governance model of the Redsun project accross the entire organization:</p> <ul> <li>Governance Model - Detailed governance structure and processes</li> <li>About BDFL - Information about the Benevolent Dictator For Life model</li> </ul>"},{"location":"governance/about_bdfl/","title":"About the BDFL","text":"<pre><code>This section is written in first person and provides a **subjective** opinion of its author.\n\n&gt; Author: Jacopo Abramo\n</code></pre> <pre><code>TLDR:\n\n- The BDFL is a temporary governance model, but required for projects still in the infancy stage.\n- At this time there's only one contributor - me.\n- I can't make everyone happy, so I'll reserve the right to have the final word on decisions.\n- In case the project picks momentum, I will be happy to shift to a different governance model.\n</code></pre> <p>The word \"dictator\" in the context of open-source projects might seem a bit misleading. It originated from a joke on how the original author of the Python programming language, Guido van Rossum, was reffered to.</p> <p>From my perspective, and based on my past experiences, I believe that a project in its infancy should have one (and only one) lead figure that gives traction to the decision making process involved in expanding the project in its core functionalities.</p> <p>This does not hinder other contributors to providing their opinion, which is actually highly encouraged and always appreciated (as long as it respects the Code of Conduct). But I have a clear set of goals for Redsun, which sometimes may clash with other contributors ideas; I can try to be as open as possible in fitting other contributor's ideas in Redsun but some of them may be too inconsistent with either the current state of the project or its goals.</p> <p>Whether to change the governance model to something different and more democratic depends majorly on how the audience responds to it. If it gains a lot of momentum and many other people become regular contributors, it becomes only natural that this model shifts to something that fits a bigger audience. But that time is yet to come.</p>"},{"location":"governance/governance/","title":"Governance model","text":"<p>Accross all the repositories under the Redsun organization, the project follows the Benevolent Dictator For Life (BDFL) governance model.</p> <p>The model described below is adapted from this template.</p> <pre><code>This governance model is **temporary**. It may be kept in the future as well as changing to a different governance form.\n\nBefore panicking at the idea of contributing to a project which lists the word \"dictator\" in its governance model, see this [section](about_bdfl.md).\n</code></pre> <pre><code>The governance model is still under draft; roles and responsabilities may change as the project evolves.\n\nThe core idea is to keep the Redsun project free and open source for all that wish to use it or contribute to it, regardless of the model.\n</code></pre>"},{"location":"governance/governance/#overview","title":"Overview","text":"<p>This project is led by a benevolent dictator and managed by the community. That is, the community actively contributes to the day-to-day maintenance of the project, but the general strategic line is drawn by the benevolent dictator. In case of disagreement, they have the last word. It is the benevolent dictator\u2019s job to resolve disputes within the community and to ensure that the project is able to progress in a coordinated way. In turn, it is the community\u2019s job to guide the decisions of the benevolent dictator through active engagement and contribution.</p>"},{"location":"governance/governance/#roles-and-responsibilities","title":"Roles and responsibilities","text":""},{"location":"governance/governance/#benevolent-dictator-project-lead","title":"Benevolent dictator (project lead)","text":"<p>Typically, the benevolent dictator, or project lead, is self-appointed. However, because the community always has the ability to fork, this person is fully answerable to the community. The project lead\u2019s role is a difficult one: they set the strategic objectives of the project and communicate these clearly to the community. They also have to understand the community as a whole and strive to satisfy as many conflicting needs as possible, while ensuring that the project survives in the long term.</p> <p>In many ways, the role of the benevolent dictator is less about dictatorship and more about diplomacy. The key is to ensure that, as the project expands, the right people are given influence over it and the community rallies behind the vision of the project lead. The lead\u2019s job is then to ensure that the committers (see below) make the right decisions on behalf of the project. Generally speaking, as long as the committers are aligned with the project\u2019s strategy, the project lead will allow them to proceed as they desire.</p>"},{"location":"governance/governance/#committers","title":"Committers","text":"<p>Committers are contributors who have made several valuable contributions to the project and are now relied upon to both write code directly to the repository and screen the contributions of others. In many cases they are programmers but it is also possible that they contribute in a different role. Typically, a committer will focus on a specific aspect of the project, and will bring a level of expertise and understanding that earns them the respect of the community and the project lead. The role of committer is not an official one, it is simply a position that influential members of the community will find themselves in as the project lead looks to them for guidance and support.</p> <p>Committers have no authority over the overall direction of the project. However, they do have the ear of the project lead. It is a committer\u2019s job to ensure that the lead is aware of the community\u2019s needs and collective objectives, and to help develop or elicit appropriate contributions to the project. Often, committers are given informal control over their specific areas of responsibility, and are assigned rights to directly modify certain areas of the source code. That is, although committers do not have explicit decision-making authority, they will often find that their actions are synonymous with the decisions made by the lead.</p>"},{"location":"governance/governance/#contributors","title":"Contributors","text":"<p>Contributors are community members who either have no desire to become committers, or have not yet been given the opportunity by the benevolent dictator. They make valuable contributions, such as those outlined in the list below, but generally do not have the authority to make direct changes to the project code. Contributors engage with the project through communication tools, such as email lists, and via reports and patches attached to issues in the issue tracker, as detailed in our community tools document.</p> <p>Anyone can become a contributor. There is no expectation of commitment to the project, no specific skill requirements and no selection process. To become a contributor, a community member simply has to perform one or more actions that are beneficial to the project.</p> <p>Some contributors will already be engaging with the project as users, but will also find themselves doing one or more of the following:</p> <ul> <li>supporting new users (current users often provide the most effective new user support);</li> <li>reporting bugs;</li> <li>identifying requirements;</li> <li>supplying graphics and web design;</li> <li>programming;</li> <li>assisting with project infrastructure;</li> <li>writing documentation;</li> <li>fixing bugs;</li> <li>adding features.</li> </ul> <p>As contributors gain experience and familiarity with the project, they may find that the project lead starts relying on them more and more. When this begins to happen, they gradually adopt the role of committer, as described above.</p>"},{"location":"governance/governance/#users","title":"Users","text":"<p>Users are community members who have a need for the project. They are the most important members of the community: without them, the project would have no purpose. Anyone can be a user; there are no specific requirements.</p> <p>Users should be encouraged to participate in the life of the project and the community as much as possible. User contributions enable the project team to ensure that they are satisfying the needs of those users. Common user activities include (but are not limited to):</p> <ul> <li>evangelising about the project;</li> <li>informing developers of project strengths and weaknesses from a new user\u2019s perspective;</li> <li>providing moral support (a \u2018thank you\u2019 goes a long way);</li> <li>providing financial support.</li> </ul> <p>Users who continue to engage with the project and its community will often find themselves becoming more and more involved. Such users may then go on to become contributors, as described above.</p>"},{"location":"governance/governance/#support","title":"Support","text":"<p>All participants in the community are encouraged to provide support for new users within the project management infrastructure. This support is provided as a way of growing the community. Those seeking support should recognise that all support activity within the project is voluntary and is therefore provided as and when time allows. A user requiring guaranteed response times or results should therefore seek to purchase a support contract from a vendor. (Of course, that vendor should be an active member of the community.) However, for those willing to engage with the project on its own terms, and willing to help support other users, the community support channels are ideal.</p>"},{"location":"governance/governance/#contribution-process","title":"Contribution process","text":"<p>Anyone can contribute to the project, regardless of their skills, as there are many ways to contribute. For instance, a contributor might be active on the project mailing list and issue tracker, or might supply patches. The various ways of contributing are described in more detail in our roles in open source document.</p>"},{"location":"governance/governance/#decision-making-process","title":"Decision-making process","text":"<p>The benevolent dictatorship model does not need a formal conflict resolution process, since the project lead\u2019s word is final. If the community chooses to question the wisdom of the actions of a committer, the project lead can review their decisions by checking the email archives, and either uphold or reverse them.</p>"},{"location":"statement/","title":"Statement of need","text":"<p>Scientific computing is a complex field with many different tools and libraries. An even more complex topic is orchestrating the acquisition of custom-built hardware setups for cutting-edge scientific projects. The desire to have a flexible framework for building custom applications for microscopy is strong in the community, but there is yet no way to find a reacheable consensus among interested parties to develop such framework.</p> <p>The following sections illustrate the decision-making process that led to the conception of Redsun:</p> <ul> <li>History - The background and development history of the project</li> <li>Mission - Project mission and core objectives</li> <li>Bluesky integration - How Redsun integrates with the Bluesky ecosystem</li> </ul>"},{"location":"statement/bluesky/","title":"Bluesky","text":"<p>The Bluesky framework is described as:</p> <p>a collection of Python libraries that are co-developed but independently useful and may be adopted a la carte.</p> <p>It was developed at the National Synchrotron Light Source II (NSLS-II), in the Brookhaven National Laboratories, Uptown, New York, USA. The goal is to provide carefully defined software interfaces, where any given piece may be used, extended or replaced. They achieve this by leveraging the concept of structural duck typing in Python, to minimize the coupling between different components.</p> <p>There are many useful features that Bluesky offers:</p> <ul> <li>Bluesky leaves the details of implementing hardware controls to lower level logic, while the higher level interface provides a flexible approach to recycle and reuse existing code.</li> <li>Bluesky provides a formal schema to store data and metadata in a manner defined as \"unopinionated\", meaning that it makes no assumption on the type of data to store, its metadata, nor the type of storage involved. This schema gives scientists the freedom to specify what is data and what is metadata without having to worry about the underlying implementation of the actual data storage format to use.</li> <li>Bluesky's run engine - a.k.a. the acquisition engine - is written upon a message protocol that allows for implement a custom run engine (which in the end is nothing more than a Python class).</li> <li>Finally, the execution of experiments is collected in so-called \"plans\", which are simple Python functions describing the sequence of operations to be performed via a set of Bluesky's messages; such messages are defined in a manner to be interpreted by different hardware components elegantly and easily.</li> </ul> <p>Just from the description above, it is clear that Bluesky offers a list of key features highly desirable for microscopists:</p> <ul> <li>a framework that can speak the same language accross multiple groups of people;</li> <li>a modular framework that can be extended and reused;</li> <li>a framework that allows to pack workflows in a manner that can be understand both by scientists and software developers.</li> </ul> <p>Furthermore, although developed in the context of beamline accelerators, Bluesky sells itself as cross-scientific, since by default it's not designed to be tied by any kind of special data structure or set of hardware components.</p> <p>The question is: how can we bring this framework to the microscopy community?</p>"},{"location":"statement/history/","title":"History","text":""},{"location":"statement/history/#state-of-the-art","title":"State of the art","text":"<p>For open-source projects, when it comes down to hardware control for microscopes, one of the most popular choices is Micro-Manager <sup>1</sup>.</p> <p>Micro-Manager is a plugin for ImageJ <sup>2</sup> that allows to control one or multiple hardware devices to control a custom-built microscope, and offers a great amount of plugins to extend its functionalities to combine data acquisition with real-time processing.</p> <p>In time, Micro-Manager has accumulated more than 200 device interfaces (called \"device adapters\") that allow to control a wide range of hardware devices. You can view the full selection of available devices in the  mmCoreAndDevices repository.</p> <p>One of the downsides is that Micro-Manager is written in Java, and in the latest years Python has become the preferred language for scientists to work with, especially in the field of Artificial Intelligence.</p> <p>In time (particularly in the last few years), a number of other projects have emerged to try and address this problem, each with their own strengths and weaknesses, and some of them tied in some capacity to Micro-Manager: either via pymmcore, the Python bindings for the C++ backend of Micro-Manager, or Pycro-Manager, a Python library that provides direct communication with the Micro-Manager application via IPC (Inter-Process Communication). It's not uncommon that when a new software project is released, users tend to ask the question \"can I use this with Micro-Manager?\", and the answer determines the appeal the project will have.</p> <p>You can find a (not-so) comprehensive list of projects on the Smart Microscopy website, together with other projects that are not listed there in this section.</p>"},{"location":"statement/history/#software-for-microscopy-workshop","title":"Software for Microscopy workshop","text":"<p>In April 2020, a white paper <sup>3</sup> was published following the Software for Microscopy workshop organized at the Janelia Research Campus, Virginia, USA. A group of research experts in the field of microscopy gathered together to discuss the current state of the art in microscopy software, evaluating its current challenges and limitations.</p> <p>TLDR</p> <ul> <li>There is a need for a modular framework that can be used to build custom applications for microscopy.</li> <li>The framework should be easy to use and understand, and should be able to be used by different groups of experts.</li> <li>The framework should be able to be used to control a wide range of hardware devices.</li> <li>The framework should be able to be used to build custom applications for microscopy.</li> <li>The framework should allow easy creation and customization of execution workflows.</li> <li>The framework should be able to be used from multiple programming languages to ensure longevity of the software.</li> </ul> <p>An excerpt of the white paper reports the considerations made by the participants in relation to the current state of the art of available hardware control software:</p> <p>An overwhelming majority of the participants were unhappy with their current approach. General sentiments were that it is often easier to build the hardware of a new microscope system compared to writing the software. Therefore, software development is often seen as a necessary burden to accomplish the goal of creating a new microscope system. In many cases sharing the software code proves difficult due to: 1. licensing issues,  2. code that was written with a very specific microscope system in mind, thus being tightly coupled to specific hardware,  3. a need to use different programming languages,  4. existing code being difficult to understand, maintain and/or extend.</p> <p>Continuing, the white paper reports the desires of the participants:</p> <p>At least three distinct groups of experts are involved in custom-build microscopes: optics experts building the microscope hardware, software developers creating the control software and UI, and the scientists using the systems in their research.  - There is an overarching desire for tools that are easy to use and understand to each of these groups.  - This brings the need for modular tools; components with limited scope that can be used in isolation and that are well described and well-documented.    - Hardware developers need building blocks that can communicate to all commonly used hardware components, must be able to specify hardware based synchronization of components, execute different orders of component state changes, acquire images through cameras, point scanners, or small area detectors, view images, and loop analysis results back into the acquisition engine.    - Software developers will need to develop, test, document, and support these tools, while the scientists using these tools will provide invaluable feedback to make the control software more versatile and robust.   - Scientists using the microscope systems highly benefit from User Interfaces that clearly guide them along the most optimal workflows. These workflows may be different depending on the microscope system and the specific experiments they are conducting. In addition, they need easy tools to change the workflow, for instance by scripting or visual programming tools. </p> <p>Furthermore, concerning programming languages, the white paper reports the following:</p> <p>We are in the midst of a diversification of programming languages used by imaging software tool developers. Whereas previously much development occurred in Java, currently Python (among others like Julia) is gaining traction. [...] Therefore, the to-be-developed modular software building blocks for microscope control should be usable from multiple programming languages to ensure longevity of these tools.</p>"},{"location":"statement/history/#references","title":"References","text":"<ol> <li> <p>Arthur D Edelstein, Mark A Tsuchida, Nenad Amodaj, Henry Pinkard, Ronald D Vale, and Nico Stuurman (2014), Advanced methods of microscope control using \u03bcManager software. Journal of Biological Methods 2014 doi:10.14440/jbm.2014.36 \u21a9</p> </li> <li> <p>Schneider, C., Rasband, W. &amp; Eliceiri, K. NIH Image to ImageJ: 25 years of image analysis. Nat Methods 9, 671\u2013675 (2012). doi:10.1038/nmeth.2089 \u21a9</p> </li> <li> <p>Software for Microscopy workshop (2020), White paper. arXiv:2005.00082 \u21a9</p> </li> </ol>"},{"location":"statement/mission/","title":"The mission","text":"<p>The mission of Redsun is to ship not an application, but a framework that can be used to \"build\" applications with minimal effort.</p> <p>The name is an hint to the fact that it sits \"on top\" of Bluesky, and tries to provide the same features:</p> <ul> <li>modularity: pick only the components you need;</li> <li>flexibility: reuse existing code;</li> <li>unopinionated: let the user decide what is data and what is metadata;</li> <li>cross-scientific: make it easy to use in different contexts.</li> </ul> <p>The main language of choice is Python, specifically CPython; scientists have a high familiarity with it, it's flexible and it's easy to learn.</p>"},{"location":"statement/mission/#architecture","title":"Architecture","text":"<p>Redsun architecture is inspired by the Model-View-Controller (MVC) pattern, but with a twist: the \"V\" now doesn't stand for \"View\", but for \"Virtual\".</p> <ul> <li>The \"Model\" layer holds the logic for handling hardware controls, where each model object represents a hardware component a set of Bluesky's protocols;</li> <li>The \"Controller\" layer wraps the Bluesky run engine and a set of sub-controllers, where each one can provide different functionalities:<ul> <li>they can simply render information to the user interface;</li> <li>they can ship plans that are not tied to any specific hardware component, but to protocols;</li> <li>they can rely on information provided by other controllers or publish information themselves;</li> </ul> </li> <li>The \"Virtual\" layer sits between the user interface and the two layers described above, and is responsible for handling the in-between communication.</li> </ul> <p>This is because in the standard MVC pattern, there's a strong correlation between the Controller and View layers, making it difficult to tie a different front-end to the same back-end.</p> <p>By decoupling this correlation, it is possible to experiment with different front-ends without having to worry about interfacing with the backend, because the Virtual layer takes care of talking to the backend for you.</p>"},{"location":"statement/mission/#modularity-via-plugins","title":"Modularity via plugins","text":"<p>Redsun aims to be built upon a set of plugins, each one providing a specific feature.</p> <p>One of the major challenges engaged by microscopists was finding a way to reuse existing code in a consistent manner so that it wouldn't be strongly tied to their own setups. Since Bluesky gives us the possibility to speak the same language accross the whole board, we can combine different pieces of code together with different functionalities together (e.g. a plugin can ship the controls for a specific hardware component, while another plugin can ship a controller that wraps a series of executable plans not tied to any specific hardware component; and the two can be used together without any problem).</p>"},{"location":"statement/mission/#accross-different-programming-languages","title":"Accross different programming languages","text":"<p>Python has a lot of great features but in some cases it may not compare very well with other languages in terms of performance, especially for multithreaded computations. For more information about the limitations of multithreading in Python, you can visit this Real Python article about the topic.</p> <p>At the same time, Python interfaces naturally with languages that are able to provide that kind of performance, like C/C++ or Rust:</p> <ul> <li>For C, CPython offers the possibility to natively develop C extensions that can interact as a normal Python package;</li> <li>For C++, projects like pybind11 (and most recently, nanobind) allow to create Python packages that provide higher performance for computational tasks;</li> <li>For Rust, the pyo3 project allows to create bindings to ship Python packages powered by Rust, which is becoming a strong and valuable alternative to the previously described languages.</li> <li>For Julia, projects like PythonCall make it possible to use Julia code from Python seaminglessly and with no performance penalty in data exchange between the two languages. This can lay down the basis for taking the best of both worlds: the flexibility of Python with the performance of multithreaded Julia.</li> <li>For GPU projects involving CUDA, projects like CuPy allow to seaminglessly write Python code with the same syntax of NumPy, but with the benefit of being run on nVidia GPUs natively.</li> </ul> <p>The list goes on and on, but the main concept to bring home is to use Redsun to \"glue\" all these languages together, whether it is for implementing a real-time processing task or to develop a device interface in a language that can go beyond the capabilities of Python itself.</p>"}]}